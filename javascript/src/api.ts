/* tslint:disable */
/* eslint-disable */
/**
 * Foresight Private REST API
 * \"Foresight Private REST API for clients\"
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: info@runforesight.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AttributeDto
 */
export interface AttributeDto {
    /**
     * 
     * @type {boolean}
     * @memberof AttributeDto
     */
    'booleanValue'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AttributeDto
     */
    'doubleValue'?: number;
    /**
     * 
     * @type {string}
     * @memberof AttributeDto
     */
    'key'?: string;
    /**
     * 
     * @type {number}
     * @memberof AttributeDto
     */
    'longValue'?: number;
    /**
     * 
     * @type {object}
     * @memberof AttributeDto
     */
    'objectValue'?: object;
    /**
     * 
     * @type {string}
     * @memberof AttributeDto
     */
    'stringValue'?: string;
}
/**
 * 
 * @export
 * @interface BranchDto
 */
export interface BranchDto {
    /**
     * 
     * @type {string}
     * @memberof BranchDto
     */
    'branchName'?: string;
}
/**
 * 
 * @export
 * @interface CPUMetricDto
 */
export interface CPUMetricDto {
    /**
     * 
     * @type {number}
     * @memberof CPUMetricDto
     */
    'cpuLoadSystem'?: number;
    /**
     * 
     * @type {number}
     * @memberof CPUMetricDto
     */
    'cpuLoadTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof CPUMetricDto
     */
    'cpuLoadUser'?: number;
}
/**
 * 
 * @export
 * @interface CompletableFutureOfVoid
 */
export interface CompletableFutureOfVoid {
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFutureOfVoid
     */
    'cancelled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFutureOfVoid
     */
    'completedExceptionally'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFutureOfVoid
     */
    'done'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CompletableFutureOfVoid
     */
    'numberOfDependents'?: number;
}
/**
 * 
 * @export
 * @interface CreateUpdateProjectDto
 */
export interface CreateUpdateProjectDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUpdateProjectDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUpdateProjectDto
     */
    'projectName'?: string;
}
/**
 * 
 * @export
 * @interface DiskMetricDto
 */
export interface DiskMetricDto {
    /**
     * 
     * @type {number}
     * @memberof DiskMetricDto
     */
    'diskIORxMb'?: number;
    /**
     * 
     * @type {number}
     * @memberof DiskMetricDto
     */
    'diskIOWxMb'?: number;
}
/**
 * 
 * @export
 * @interface ErroneousWorkflowDto
 */
export interface ErroneousWorkflowDto {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ErroneousWorkflowDto
     */
    'errorCounts'?: { [key: string]: number; };
    /**
     * 
     * @type {string}
     * @memberof ErroneousWorkflowDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErroneousWorkflowDto
     */
    'name'?: string;
    /**
     * 
     * @type {RepoDto}
     * @memberof ErroneousWorkflowDto
     */
    'repo'?: RepoDto;
    /**
     * 
     * @type {number}
     * @memberof ErroneousWorkflowDto
     */
    'totalErrorCount'?: number;
}
/**
 * 
 * @export
 * @interface EventDto
 */
export interface EventDto {
    /**
     * 
     * @type {string}
     * @memberof EventDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventDto
     */
    'time'?: number;
}
/**
 * 
 * @export
 * @interface MemoryMetricDto
 */
export interface MemoryMetricDto {
    /**
     * 
     * @type {number}
     * @memberof MemoryMetricDto
     */
    'memoryUsageActive'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryMetricDto
     */
    'memoryUsageAvailable'?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryMetricDto
     */
    'memoryUsageTotal'?: number;
}
/**
 * 
 * @export
 * @interface NetworkMetricDto
 */
export interface NetworkMetricDto {
    /**
     * 
     * @type {number}
     * @memberof NetworkMetricDto
     */
    'networkIORxMb'?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkMetricDto
     */
    'networkIOTxMb'?: number;
}
/**
 * 
 * @export
 * @interface ProcessDto
 */
export interface ProcessDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProcessDto
     */
    'args'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProcessDto
     */
    'domain'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProcessDto
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProcessDto
     */
    'exitCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProcessDto
     */
    'fileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProcessDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProcessDto
     */
    'kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProcessDto
     */
    'parentId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProcessDto
     */
    'startTime'?: number;
    /**
     * 
     * @type {object}
     * @memberof ProcessDto
     */
    'tags'?: object;
    /**
     * 
     * @type {number}
     * @memberof ProcessDto
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface ProjectSummaryDto
 */
export interface ProjectSummaryDto {
    /**
     * 
     * @type {number}
     * @memberof ProjectSummaryDto
     */
    'createdAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectSummaryDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectSummaryDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectSummaryDto
     */
    'projectName'?: string;
}
/**
 * 
 * @export
 * @interface RepoDto
 */
export interface RepoDto {
    /**
     * 
     * @type {string}
     * @memberof RepoDto
     */
    'accountOwnerUserAccountId'?: string;
    /**
     * 
     * @type {number}
     * @memberof RepoDto
     */
    'createdAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof RepoDto
     */
    'defaultBranch'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepoDto
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepoDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepoDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepoDto
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepoDto
     */
    'provider'?: RepoDtoProviderEnum;
    /**
     * 
     * @type {boolean}
     * @memberof RepoDto
     */
    'publiclyAccessible'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RepoDto
     */
    'repoInformedStatus'?: RepoDtoRepoInformedStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof RepoDto
     */
    'userId'?: string;
}

export const RepoDtoProviderEnum = {
    Git: 'GIT',
    Github: 'GITHUB',
    Gitlab: 'GITLAB',
    Bitbucket: 'BITBUCKET',
    Azure: 'AZURE',
    Travisci: 'TRAVISCI',
    Circleci: 'CIRCLECI',
    Jenkins: 'JENKINS',
    Codebuild: 'CODEBUILD'
} as const;

export type RepoDtoProviderEnum = typeof RepoDtoProviderEnum[keyof typeof RepoDtoProviderEnum];
export const RepoDtoRepoInformedStatusEnum = {
    Initial: 'INITIAL',
    Started: 'STARTED',
    Completed: 'COMPLETED',
    CompletedWithNoWorkflow: 'COMPLETED_WITH_NO_WORKFLOW',
    Error: 'ERROR'
} as const;

export type RepoDtoRepoInformedStatusEnum = typeof RepoDtoRepoInformedStatusEnum[keyof typeof RepoDtoRepoInformedStatusEnum];

/**
 * 
 * @export
 * @interface RepoSearchDto
 */
export interface RepoSearchDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof RepoSearchDto
     */
    'branches'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RepoSearchDto
     */
    'repoId'?: string;
}
/**
 * 
 * @export
 * @interface RepoSummaryDto
 */
export interface RepoSummaryDto {
    /**
     * 
     * @type {string}
     * @memberof RepoSummaryDto
     */
    'defaultBranch'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepoSummaryDto
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepoSummaryDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepoSummaryDto
     */
    'owner'?: string;
}
/**
 * 
 * @export
 * @interface SpanDto
 */
export interface SpanDto {
    /**
     * 
     * @type {Array<AttributeDto>}
     * @memberof SpanDto
     */
    'attributes'?: Array<AttributeDto>;
    /**
     * 
     * @type {number}
     * @memberof SpanDto
     */
    'duration'?: number;
    /**
     * 
     * @type {Array<EventDto>}
     * @memberof SpanDto
     */
    'events'?: Array<EventDto>;
    /**
     * 
     * @type {number}
     * @memberof SpanDto
     */
    'finishTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof SpanDto
     */
    'kind'?: number;
    /**
     * 
     * @type {string}
     * @memberof SpanDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpanDto
     */
    'organizationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpanDto
     */
    'parentSpanId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpanDto
     */
    'repoId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpanDto
     */
    'spanId'?: string;
    /**
     * 
     * @type {number}
     * @memberof SpanDto
     */
    'startTime'?: number;
    /**
     * 
     * @type {SpanStatus}
     * @memberof SpanDto
     */
    'status'?: SpanStatus;
    /**
     * 
     * @type {string}
     * @memberof SpanDto
     */
    'traceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpanDto
     */
    'userAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpanDto
     */
    'workflowRunId'?: string;
}
/**
 * 
 * @export
 * @interface SpanStatus
 */
export interface SpanStatus {
    /**
     * 
     * @type {number}
     * @memberof SpanStatus
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof SpanStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UnwatchRepoDto
 */
export interface UnwatchRepoDto {
    /**
     * 
     * @type {string}
     * @memberof UnwatchRepoDto
     */
    'projectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnwatchRepoDto
     */
    'repoFullName'?: string;
}
/**
 * 
 * @export
 * @interface WatchRepoDto
 */
export interface WatchRepoDto {
    /**
     * 
     * @type {string}
     * @memberof WatchRepoDto
     */
    'projectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchRepoDto
     */
    'repoFullName'?: string;
}
/**
 * 
 * @export
 * @interface WatchedRepoFilterDto
 */
export interface WatchedRepoFilterDto {
    /**
     * 
     * @type {string}
     * @memberof WatchedRepoFilterDto
     */
    'repoId'?: string;
}
/**
 * 
 * @export
 * @interface WorkflowDto
 */
export interface WorkflowDto {
    /**
     * 
     * @type {string}
     * @memberof WorkflowDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface WorkflowHighlightsQueryDto
 */
export interface WorkflowHighlightsQueryDto {
    /**
     * 
     * @type {Array<BranchDto>}
     * @memberof WorkflowHighlightsQueryDto
     */
    'branches'?: Array<BranchDto>;
    /**
     * 
     * @type {string}
     * @memberof WorkflowHighlightsQueryDto
     */
    'projectId'?: string;
    /**
     * 
     * @type {Array<WatchedRepoFilterDto>}
     * @memberof WorkflowHighlightsQueryDto
     */
    'repos'?: Array<WatchedRepoFilterDto>;
    /**
     * 
     * @type {number}
     * @memberof WorkflowHighlightsQueryDto
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowHighlightsQueryDto
     */
    'timeRange'?: string;
}
/**
 * 
 * @export
 * @interface WorkflowJobMetricDtoOfCPUMetricDto
 */
export interface WorkflowJobMetricDtoOfCPUMetricDto {
    /**
     * 
     * @type {{ [key: string]: CPUMetricDto; }}
     * @memberof WorkflowJobMetricDtoOfCPUMetricDto
     */
    'metrics'?: { [key: string]: CPUMetricDto; };
}
/**
 * 
 * @export
 * @interface WorkflowJobMetricDtoOfDiskMetricDto
 */
export interface WorkflowJobMetricDtoOfDiskMetricDto {
    /**
     * 
     * @type {{ [key: string]: DiskMetricDto; }}
     * @memberof WorkflowJobMetricDtoOfDiskMetricDto
     */
    'metrics'?: { [key: string]: DiskMetricDto; };
}
/**
 * 
 * @export
 * @interface WorkflowJobMetricDtoOfMemoryMetricDto
 */
export interface WorkflowJobMetricDtoOfMemoryMetricDto {
    /**
     * 
     * @type {{ [key: string]: MemoryMetricDto; }}
     * @memberof WorkflowJobMetricDtoOfMemoryMetricDto
     */
    'metrics'?: { [key: string]: MemoryMetricDto; };
}
/**
 * 
 * @export
 * @interface WorkflowJobMetricDtoOfNetworkMetricDto
 */
export interface WorkflowJobMetricDtoOfNetworkMetricDto {
    /**
     * 
     * @type {{ [key: string]: NetworkMetricDto; }}
     * @memberof WorkflowJobMetricDtoOfNetworkMetricDto
     */
    'metrics'?: { [key: string]: NetworkMetricDto; };
}
/**
 * 
 * @export
 * @interface WorkflowRunSummaryDto
 */
export interface WorkflowRunSummaryDto {
    /**
     * 
     * @type {string}
     * @memberof WorkflowRunSummaryDto
     */
    'conclusion'?: WorkflowRunSummaryDtoConclusionEnum;
    /**
     * 
     * @type {number}
     * @memberof WorkflowRunSummaryDto
     */
    'createdAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowRunSummaryDto
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowRunSummaryDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowRunSummaryDto
     */
    'provider'?: WorkflowRunSummaryDtoProviderEnum;
    /**
     * 
     * @type {RepoDto}
     * @memberof WorkflowRunSummaryDto
     */
    'repo'?: RepoDto;
    /**
     * 
     * @type {string}
     * @memberof WorkflowRunSummaryDto
     */
    'repoId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowRunSummaryDto
     */
    'runId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowRunSummaryDto
     */
    'status'?: WorkflowRunSummaryDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkflowRunSummaryDto
     */
    'userAccountId'?: string;
    /**
     * 
     * @type {WorkflowDto}
     * @memberof WorkflowRunSummaryDto
     */
    'workflow'?: WorkflowDto;
}

export const WorkflowRunSummaryDtoConclusionEnum = {
    ActionRequired: 'ACTION_REQUIRED',
    Cancelled: 'CANCELLED',
    Failure: 'FAILURE',
    Neutral: 'NEUTRAL',
    Success: 'SUCCESS',
    Skipped: 'SKIPPED',
    Stale: 'STALE',
    TimedOut: 'TIMED_OUT',
    Unknown: 'UNKNOWN'
} as const;

export type WorkflowRunSummaryDtoConclusionEnum = typeof WorkflowRunSummaryDtoConclusionEnum[keyof typeof WorkflowRunSummaryDtoConclusionEnum];
export const WorkflowRunSummaryDtoProviderEnum = {
    Github: 'GITHUB'
} as const;

export type WorkflowRunSummaryDtoProviderEnum = typeof WorkflowRunSummaryDtoProviderEnum[keyof typeof WorkflowRunSummaryDtoProviderEnum];
export const WorkflowRunSummaryDtoStatusEnum = {
    Queued: 'QUEUED',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Unknown: 'UNKNOWN'
} as const;

export type WorkflowRunSummaryDtoStatusEnum = typeof WorkflowRunSummaryDtoStatusEnum[keyof typeof WorkflowRunSummaryDtoStatusEnum];

/**
 * 
 * @export
 * @interface WorkflowSearchDto
 */
export interface WorkflowSearchDto {
    /**
     * 
     * @type {number}
     * @memberof WorkflowSearchDto
     */
    'endDate'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSearchDto
     */
    'filterText'?: string;
    /**
     * 
     * @type {Array<RepoSearchDto>}
     * @memberof WorkflowSearchDto
     */
    'repos'?: Array<RepoSearchDto>;
    /**
     * 
     * @type {number}
     * @memberof WorkflowSearchDto
     */
    'startDate'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkflowSearchDto
     */
    'statuses'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WorkflowStepDto
 */
export interface WorkflowStepDto {
    /**
     * 
     * @type {number}
     * @memberof WorkflowStepDto
     */
    'completedAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStepDto
     */
    'conclusion'?: WorkflowStepDtoConclusionEnum;
    /**
     * 
     * @type {number}
     * @memberof WorkflowStepDto
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStepDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStepDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowStepDto
     */
    'number'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowStepDto
     */
    'startedAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStepDto
     */
    'status'?: WorkflowStepDtoStatusEnum;
}

export const WorkflowStepDtoConclusionEnum = {
    ActionRequired: 'ACTION_REQUIRED',
    Cancelled: 'CANCELLED',
    Failure: 'FAILURE',
    Neutral: 'NEUTRAL',
    Success: 'SUCCESS',
    Skipped: 'SKIPPED',
    Stale: 'STALE',
    TimedOut: 'TIMED_OUT',
    Unknown: 'UNKNOWN'
} as const;

export type WorkflowStepDtoConclusionEnum = typeof WorkflowStepDtoConclusionEnum[keyof typeof WorkflowStepDtoConclusionEnum];
export const WorkflowStepDtoStatusEnum = {
    Queued: 'QUEUED',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Unknown: 'UNKNOWN'
} as const;

export type WorkflowStepDtoStatusEnum = typeof WorkflowStepDtoStatusEnum[keyof typeof WorkflowStepDtoStatusEnum];

/**
 * 
 * @export
 * @interface WorkflowStepHistoryDto
 */
export interface WorkflowStepHistoryDto {
    /**
     * 
     * @type {string}
     * @memberof WorkflowStepHistoryDto
     */
    'jobName'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStepHistoryDto
     */
    'stepName'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStepHistoryDto
     */
    'stepNumber'?: string;
    /**
     * 
     * @type {Array<WorkflowStepDto>}
     * @memberof WorkflowStepHistoryDto
     */
    'workflowStepDtoList'?: Array<WorkflowStepDto>;
}
/**
 * 
 * @export
 * @interface WorkflowStepHistoryRequestDto
 */
export interface WorkflowStepHistoryRequestDto {
    /**
     * 
     * @type {number}
     * @memberof WorkflowStepHistoryRequestDto
     */
    'endTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStepHistoryRequestDto
     */
    'jobName'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowStepHistoryRequestDto
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowStepHistoryRequestDto
     */
    'startTime'?: number;
}
/**
 * 
 * @export
 * @interface WorkflowTelemetryRequest
 */
export interface WorkflowTelemetryRequest {
    /**
     * 
     * @type {object}
     * @memberof WorkflowTelemetryRequest
     */
    'metaData'?: object;
    /**
     * 
     * @type {object}
     * @memberof WorkflowTelemetryRequest
     */
    'telemetryData'?: object;
}
/**
 * 
 * @export
 * @interface WorkflowViewDto
 */
export interface WorkflowViewDto {
    /**
     * 
     * @type {number}
     * @memberof WorkflowViewDto
     */
    'averageDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowViewDto
     */
    'executionCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowViewDto
     */
    'failAverageDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowViewDto
     */
    'failCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowViewDto
     */
    'failMedianDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowViewDto
     */
    'failP95Duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowViewDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowViewDto
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowViewDto
     */
    'otherCount'?: number;
    /**
     * 
     * @type {RepoDto}
     * @memberof WorkflowViewDto
     */
    'repo'?: RepoDto;
    /**
     * 
     * @type {number}
     * @memberof WorkflowViewDto
     */
    'successAverageDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowViewDto
     */
    'successCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowViewDto
     */
    'successMedianDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowViewDto
     */
    'successP95Duration'?: number;
    /**
     * 
     * @type {Array<WorkflowRunSummaryDto>}
     * @memberof WorkflowViewDto
     */
    'workflowRuns'?: Array<WorkflowRunSummaryDto>;
}

/**
 * BadgeControllerApi - axios parameter creator
 * @export
 */
export const BadgeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary pullRequestTestCountBadgeByRepoId
         * @param {number} prNumber prNumber
         * @param {string} repoId repoId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullRequestTestCountBadgeByRepoIdUsingGET: async (prNumber: number, repoId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prNumber' is not null or undefined
            assertParamExists('pullRequestTestCountBadgeByRepoIdUsingGET', 'prNumber', prNumber)
            // verify required parameter 'repoId' is not null or undefined
            assertParamExists('pullRequestTestCountBadgeByRepoIdUsingGET', 'repoId', repoId)
            const localVarPath = `/api/v1/badge/repository/{repoId}/pull-request/{prNumber}/testCount`
                .replace(`{${"prNumber"}}`, encodeURIComponent(String(prNumber)))
                .replace(`{${"repoId"}}`, encodeURIComponent(String(repoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary pullRequestTestRunTotalDuration
         * @param {number} prNumber prNumber
         * @param {string} repoId repoId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullRequestTestRunTotalDurationUsingGET: async (prNumber: number, repoId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prNumber' is not null or undefined
            assertParamExists('pullRequestTestRunTotalDurationUsingGET', 'prNumber', prNumber)
            // verify required parameter 'repoId' is not null or undefined
            assertParamExists('pullRequestTestRunTotalDurationUsingGET', 'repoId', repoId)
            const localVarPath = `/api/v1/badge/repository/{repoId}/pull-request/{prNumber}/testRunDuration`
                .replace(`{${"prNumber"}}`, encodeURIComponent(String(prNumber)))
                .replace(`{${"repoId"}}`, encodeURIComponent(String(repoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary pullRequestWorkflowConclusionsBadgeByRepoId
         * @param {number} prNumber prNumber
         * @param {string} repoId repoId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullRequestWorkflowConclusionsBadgeByRepoIdUsingGET: async (prNumber: number, repoId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prNumber' is not null or undefined
            assertParamExists('pullRequestWorkflowConclusionsBadgeByRepoIdUsingGET', 'prNumber', prNumber)
            // verify required parameter 'repoId' is not null or undefined
            assertParamExists('pullRequestWorkflowConclusionsBadgeByRepoIdUsingGET', 'repoId', repoId)
            const localVarPath = `/api/v1/badge/repository/{repoId}/pull-request/{prNumber}/workflowConclusion`
                .replace(`{${"prNumber"}}`, encodeURIComponent(String(prNumber)))
                .replace(`{${"repoId"}}`, encodeURIComponent(String(repoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary pullRequestWorkflowRunTotalDuration
         * @param {number} prNumber prNumber
         * @param {string} repoId repoId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullRequestWorkflowRunTotalDurationUsingGET: async (prNumber: number, repoId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prNumber' is not null or undefined
            assertParamExists('pullRequestWorkflowRunTotalDurationUsingGET', 'prNumber', prNumber)
            // verify required parameter 'repoId' is not null or undefined
            assertParamExists('pullRequestWorkflowRunTotalDurationUsingGET', 'repoId', repoId)
            const localVarPath = `/api/v1/badge/repository/{repoId}/pull-request/{prNumber}/workflowRunDuration`
                .replace(`{${"prNumber"}}`, encodeURIComponent(String(prNumber)))
                .replace(`{${"repoId"}}`, encodeURIComponent(String(repoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary successBadgeByRepoId
         * @param {string} repoId repoId
         * @param {string} [branch] branch
         * @param {string} [workflowName] workflowName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        successBadgeByRepoIdUsingGET: async (repoId: string, branch?: string, workflowName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoId' is not null or undefined
            assertParamExists('successBadgeByRepoIdUsingGET', 'repoId', repoId)
            const localVarPath = `/api/v1/badge/success`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (repoId !== undefined) {
                localVarQueryParameter['repoId'] = repoId;
            }

            if (workflowName !== undefined) {
                localVarQueryParameter['workflowName'] = workflowName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary testSummaryBadgeByRepoId
         * @param {string} repoId repoId
         * @param {string} [branch] branch
         * @param {string} [workflowName] workflowName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testSummaryBadgeByRepoIdUsingGET: async (repoId: string, branch?: string, workflowName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoId' is not null or undefined
            assertParamExists('testSummaryBadgeByRepoIdUsingGET', 'repoId', repoId)
            const localVarPath = `/api/v1/badge/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (repoId !== undefined) {
                localVarQueryParameter['repoId'] = repoId;
            }

            if (workflowName !== undefined) {
                localVarQueryParameter['workflowName'] = workflowName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary utilizationBadgeByRepoId
         * @param {string} repoId repoId
         * @param {string} [branch] branch
         * @param {string} [workflowName] workflowName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        utilizationBadgeByRepoIdUsingGET: async (repoId: string, branch?: string, workflowName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoId' is not null or undefined
            assertParamExists('utilizationBadgeByRepoIdUsingGET', 'repoId', repoId)
            const localVarPath = `/api/v1/badge/utilization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (repoId !== undefined) {
                localVarQueryParameter['repoId'] = repoId;
            }

            if (workflowName !== undefined) {
                localVarQueryParameter['workflowName'] = workflowName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BadgeControllerApi - functional programming interface
 * @export
 */
export const BadgeControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BadgeControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary pullRequestTestCountBadgeByRepoId
         * @param {number} prNumber prNumber
         * @param {string} repoId repoId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pullRequestTestCountBadgeByRepoIdUsingGET(prNumber: number, repoId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pullRequestTestCountBadgeByRepoIdUsingGET(prNumber, repoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary pullRequestTestRunTotalDuration
         * @param {number} prNumber prNumber
         * @param {string} repoId repoId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pullRequestTestRunTotalDurationUsingGET(prNumber: number, repoId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pullRequestTestRunTotalDurationUsingGET(prNumber, repoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary pullRequestWorkflowConclusionsBadgeByRepoId
         * @param {number} prNumber prNumber
         * @param {string} repoId repoId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pullRequestWorkflowConclusionsBadgeByRepoIdUsingGET(prNumber: number, repoId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pullRequestWorkflowConclusionsBadgeByRepoIdUsingGET(prNumber, repoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary pullRequestWorkflowRunTotalDuration
         * @param {number} prNumber prNumber
         * @param {string} repoId repoId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pullRequestWorkflowRunTotalDurationUsingGET(prNumber: number, repoId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pullRequestWorkflowRunTotalDurationUsingGET(prNumber, repoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary successBadgeByRepoId
         * @param {string} repoId repoId
         * @param {string} [branch] branch
         * @param {string} [workflowName] workflowName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async successBadgeByRepoIdUsingGET(repoId: string, branch?: string, workflowName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.successBadgeByRepoIdUsingGET(repoId, branch, workflowName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary testSummaryBadgeByRepoId
         * @param {string} repoId repoId
         * @param {string} [branch] branch
         * @param {string} [workflowName] workflowName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testSummaryBadgeByRepoIdUsingGET(repoId: string, branch?: string, workflowName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testSummaryBadgeByRepoIdUsingGET(repoId, branch, workflowName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary utilizationBadgeByRepoId
         * @param {string} repoId repoId
         * @param {string} [branch] branch
         * @param {string} [workflowName] workflowName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async utilizationBadgeByRepoIdUsingGET(repoId: string, branch?: string, workflowName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.utilizationBadgeByRepoIdUsingGET(repoId, branch, workflowName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BadgeControllerApi - factory interface
 * @export
 */
export const BadgeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BadgeControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary pullRequestTestCountBadgeByRepoId
         * @param {number} prNumber prNumber
         * @param {string} repoId repoId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullRequestTestCountBadgeByRepoIdUsingGET(prNumber: number, repoId: string, options?: any): AxiosPromise<string> {
            return localVarFp.pullRequestTestCountBadgeByRepoIdUsingGET(prNumber, repoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary pullRequestTestRunTotalDuration
         * @param {number} prNumber prNumber
         * @param {string} repoId repoId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullRequestTestRunTotalDurationUsingGET(prNumber: number, repoId: string, options?: any): AxiosPromise<string> {
            return localVarFp.pullRequestTestRunTotalDurationUsingGET(prNumber, repoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary pullRequestWorkflowConclusionsBadgeByRepoId
         * @param {number} prNumber prNumber
         * @param {string} repoId repoId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullRequestWorkflowConclusionsBadgeByRepoIdUsingGET(prNumber: number, repoId: string, options?: any): AxiosPromise<string> {
            return localVarFp.pullRequestWorkflowConclusionsBadgeByRepoIdUsingGET(prNumber, repoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary pullRequestWorkflowRunTotalDuration
         * @param {number} prNumber prNumber
         * @param {string} repoId repoId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullRequestWorkflowRunTotalDurationUsingGET(prNumber: number, repoId: string, options?: any): AxiosPromise<string> {
            return localVarFp.pullRequestWorkflowRunTotalDurationUsingGET(prNumber, repoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary successBadgeByRepoId
         * @param {string} repoId repoId
         * @param {string} [branch] branch
         * @param {string} [workflowName] workflowName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        successBadgeByRepoIdUsingGET(repoId: string, branch?: string, workflowName?: string, options?: any): AxiosPromise<string> {
            return localVarFp.successBadgeByRepoIdUsingGET(repoId, branch, workflowName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary testSummaryBadgeByRepoId
         * @param {string} repoId repoId
         * @param {string} [branch] branch
         * @param {string} [workflowName] workflowName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testSummaryBadgeByRepoIdUsingGET(repoId: string, branch?: string, workflowName?: string, options?: any): AxiosPromise<string> {
            return localVarFp.testSummaryBadgeByRepoIdUsingGET(repoId, branch, workflowName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary utilizationBadgeByRepoId
         * @param {string} repoId repoId
         * @param {string} [branch] branch
         * @param {string} [workflowName] workflowName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        utilizationBadgeByRepoIdUsingGET(repoId: string, branch?: string, workflowName?: string, options?: any): AxiosPromise<string> {
            return localVarFp.utilizationBadgeByRepoIdUsingGET(repoId, branch, workflowName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BadgeControllerApi - object-oriented interface
 * @export
 * @class BadgeControllerApi
 * @extends {BaseAPI}
 */
export class BadgeControllerApi extends BaseAPI {
    /**
     * 
     * @summary pullRequestTestCountBadgeByRepoId
     * @param {number} prNumber prNumber
     * @param {string} repoId repoId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BadgeControllerApi
     */
    public pullRequestTestCountBadgeByRepoIdUsingGET(prNumber: number, repoId: string, options?: AxiosRequestConfig) {
        return BadgeControllerApiFp(this.configuration).pullRequestTestCountBadgeByRepoIdUsingGET(prNumber, repoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary pullRequestTestRunTotalDuration
     * @param {number} prNumber prNumber
     * @param {string} repoId repoId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BadgeControllerApi
     */
    public pullRequestTestRunTotalDurationUsingGET(prNumber: number, repoId: string, options?: AxiosRequestConfig) {
        return BadgeControllerApiFp(this.configuration).pullRequestTestRunTotalDurationUsingGET(prNumber, repoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary pullRequestWorkflowConclusionsBadgeByRepoId
     * @param {number} prNumber prNumber
     * @param {string} repoId repoId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BadgeControllerApi
     */
    public pullRequestWorkflowConclusionsBadgeByRepoIdUsingGET(prNumber: number, repoId: string, options?: AxiosRequestConfig) {
        return BadgeControllerApiFp(this.configuration).pullRequestWorkflowConclusionsBadgeByRepoIdUsingGET(prNumber, repoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary pullRequestWorkflowRunTotalDuration
     * @param {number} prNumber prNumber
     * @param {string} repoId repoId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BadgeControllerApi
     */
    public pullRequestWorkflowRunTotalDurationUsingGET(prNumber: number, repoId: string, options?: AxiosRequestConfig) {
        return BadgeControllerApiFp(this.configuration).pullRequestWorkflowRunTotalDurationUsingGET(prNumber, repoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary successBadgeByRepoId
     * @param {string} repoId repoId
     * @param {string} [branch] branch
     * @param {string} [workflowName] workflowName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BadgeControllerApi
     */
    public successBadgeByRepoIdUsingGET(repoId: string, branch?: string, workflowName?: string, options?: AxiosRequestConfig) {
        return BadgeControllerApiFp(this.configuration).successBadgeByRepoIdUsingGET(repoId, branch, workflowName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary testSummaryBadgeByRepoId
     * @param {string} repoId repoId
     * @param {string} [branch] branch
     * @param {string} [workflowName] workflowName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BadgeControllerApi
     */
    public testSummaryBadgeByRepoIdUsingGET(repoId: string, branch?: string, workflowName?: string, options?: AxiosRequestConfig) {
        return BadgeControllerApiFp(this.configuration).testSummaryBadgeByRepoIdUsingGET(repoId, branch, workflowName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary utilizationBadgeByRepoId
     * @param {string} repoId repoId
     * @param {string} [branch] branch
     * @param {string} [workflowName] workflowName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BadgeControllerApi
     */
    public utilizationBadgeByRepoIdUsingGET(repoId: string, branch?: string, workflowName?: string, options?: AxiosRequestConfig) {
        return BadgeControllerApiFp(this.configuration).utilizationBadgeByRepoIdUsingGET(repoId, branch, workflowName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getJobCPUMetrics
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobCPUMetricsUsingGET: async (jobId: string, workflowRunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobCPUMetricsUsingGET', 'jobId', jobId)
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('getJobCPUMetricsUsingGET', 'workflowRunId', workflowRunId)
            const localVarPath = `/api/workflow-runs/{workflowRunId}/jobs/{jobId}/metrics/cpu`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"workflowRunId"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getJobDiskMetrics
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDiskMetricsUsingGET: async (jobId: string, workflowRunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobDiskMetricsUsingGET', 'jobId', jobId)
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('getJobDiskMetricsUsingGET', 'workflowRunId', workflowRunId)
            const localVarPath = `/api/workflow-runs/{workflowRunId}/jobs/{jobId}/metrics/disk`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"workflowRunId"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getJobMemoryMetrics
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobMemoryMetricsUsingGET: async (jobId: string, workflowRunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobMemoryMetricsUsingGET', 'jobId', jobId)
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('getJobMemoryMetricsUsingGET', 'workflowRunId', workflowRunId)
            const localVarPath = `/api/workflow-runs/{workflowRunId}/jobs/{jobId}/metrics/memory`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"workflowRunId"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getJobNetworkMetrics
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobNetworkMetricsUsingGET: async (jobId: string, workflowRunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobNetworkMetricsUsingGET', 'jobId', jobId)
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('getJobNetworkMetricsUsingGET', 'workflowRunId', workflowRunId)
            const localVarPath = `/api/workflow-runs/{workflowRunId}/jobs/{jobId}/metrics/network`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"workflowRunId"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary getJobCPUMetrics
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobCPUMetricsUsingGET(jobId: string, workflowRunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowJobMetricDtoOfCPUMetricDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobCPUMetricsUsingGET(jobId, workflowRunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getJobDiskMetrics
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobDiskMetricsUsingGET(jobId: string, workflowRunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowJobMetricDtoOfDiskMetricDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobDiskMetricsUsingGET(jobId, workflowRunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getJobMemoryMetrics
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobMemoryMetricsUsingGET(jobId: string, workflowRunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowJobMetricDtoOfMemoryMetricDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobMemoryMetricsUsingGET(jobId, workflowRunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getJobNetworkMetrics
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobNetworkMetricsUsingGET(jobId: string, workflowRunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowJobMetricDtoOfNetworkMetricDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobNetworkMetricsUsingGET(jobId, workflowRunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary getJobCPUMetrics
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobCPUMetricsUsingGET(jobId: string, workflowRunId: string, options?: any): AxiosPromise<WorkflowJobMetricDtoOfCPUMetricDto> {
            return localVarFp.getJobCPUMetricsUsingGET(jobId, workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getJobDiskMetrics
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDiskMetricsUsingGET(jobId: string, workflowRunId: string, options?: any): AxiosPromise<WorkflowJobMetricDtoOfDiskMetricDto> {
            return localVarFp.getJobDiskMetricsUsingGET(jobId, workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getJobMemoryMetrics
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobMemoryMetricsUsingGET(jobId: string, workflowRunId: string, options?: any): AxiosPromise<WorkflowJobMetricDtoOfMemoryMetricDto> {
            return localVarFp.getJobMemoryMetricsUsingGET(jobId, workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getJobNetworkMetrics
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobNetworkMetricsUsingGET(jobId: string, workflowRunId: string, options?: any): AxiosPromise<WorkflowJobMetricDtoOfNetworkMetricDto> {
            return localVarFp.getJobNetworkMetricsUsingGET(jobId, workflowRunId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * 
     * @summary getJobCPUMetrics
     * @param {string} jobId jobId
     * @param {string} workflowRunId workflowRunId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getJobCPUMetricsUsingGET(jobId: string, workflowRunId: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getJobCPUMetricsUsingGET(jobId, workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getJobDiskMetrics
     * @param {string} jobId jobId
     * @param {string} workflowRunId workflowRunId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getJobDiskMetricsUsingGET(jobId: string, workflowRunId: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getJobDiskMetricsUsingGET(jobId, workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getJobMemoryMetrics
     * @param {string} jobId jobId
     * @param {string} workflowRunId workflowRunId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getJobMemoryMetricsUsingGET(jobId: string, workflowRunId: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getJobMemoryMetricsUsingGET(jobId, workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getJobNetworkMetrics
     * @param {string} jobId jobId
     * @param {string} workflowRunId workflowRunId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getJobNetworkMetricsUsingGET(jobId: string, workflowRunId: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getJobNetworkMetricsUsingGET(jobId, workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProcessesApi - axios parameter creator
 * @export
 */
export const ProcessesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getJobProcessSpans
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {'FAILURE' | 'DURATION'} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobProcessSpansUsingGET: async (jobId: string, workflowRunId: string, sort?: 'FAILURE' | 'DURATION', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobProcessSpansUsingGET', 'jobId', jobId)
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('getJobProcessSpansUsingGET', 'workflowRunId', workflowRunId)
            const localVarPath = `/api/workflow-runs/{workflowRunId}/jobs/{jobId}/spans`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"workflowRunId"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getJobProcesses
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {'FAILURE' | 'DURATION'} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobProcessesUsingGET: async (jobId: string, workflowRunId: string, sort?: 'FAILURE' | 'DURATION', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobProcessesUsingGET', 'jobId', jobId)
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('getJobProcessesUsingGET', 'workflowRunId', workflowRunId)
            const localVarPath = `/api/workflow-runs/{workflowRunId}/jobs/{jobId}/processes`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"workflowRunId"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessesApi - functional programming interface
 * @export
 */
export const ProcessesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary getJobProcessSpans
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {'FAILURE' | 'DURATION'} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobProcessSpansUsingGET(jobId: string, workflowRunId: string, sort?: 'FAILURE' | 'DURATION', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpanDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobProcessSpansUsingGET(jobId, workflowRunId, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getJobProcesses
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {'FAILURE' | 'DURATION'} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobProcessesUsingGET(jobId: string, workflowRunId: string, sort?: 'FAILURE' | 'DURATION', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProcessDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobProcessesUsingGET(jobId, workflowRunId, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProcessesApi - factory interface
 * @export
 */
export const ProcessesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessesApiFp(configuration)
    return {
        /**
         * 
         * @summary getJobProcessSpans
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {'FAILURE' | 'DURATION'} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobProcessSpansUsingGET(jobId: string, workflowRunId: string, sort?: 'FAILURE' | 'DURATION', options?: any): AxiosPromise<Array<SpanDto>> {
            return localVarFp.getJobProcessSpansUsingGET(jobId, workflowRunId, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getJobProcesses
         * @param {string} jobId jobId
         * @param {string} workflowRunId workflowRunId
         * @param {'FAILURE' | 'DURATION'} [sort] sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobProcessesUsingGET(jobId: string, workflowRunId: string, sort?: 'FAILURE' | 'DURATION', options?: any): AxiosPromise<Array<ProcessDto>> {
            return localVarFp.getJobProcessesUsingGET(jobId, workflowRunId, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProcessesApi - object-oriented interface
 * @export
 * @class ProcessesApi
 * @extends {BaseAPI}
 */
export class ProcessesApi extends BaseAPI {
    /**
     * 
     * @summary getJobProcessSpans
     * @param {string} jobId jobId
     * @param {string} workflowRunId workflowRunId
     * @param {'FAILURE' | 'DURATION'} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessesApi
     */
    public getJobProcessSpansUsingGET(jobId: string, workflowRunId: string, sort?: 'FAILURE' | 'DURATION', options?: AxiosRequestConfig) {
        return ProcessesApiFp(this.configuration).getJobProcessSpansUsingGET(jobId, workflowRunId, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getJobProcesses
     * @param {string} jobId jobId
     * @param {string} workflowRunId workflowRunId
     * @param {'FAILURE' | 'DURATION'} [sort] sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessesApi
     */
    public getJobProcessesUsingGET(jobId: string, workflowRunId: string, sort?: 'FAILURE' | 'DURATION', options?: AxiosRequestConfig) {
        return ProcessesApiFp(this.configuration).getJobProcessesUsingGET(jobId, workflowRunId, sort, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createProject
         * @param {CreateUpdateProjectDto} projectDto projectDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectUsingPOST: async (projectDto: CreateUpdateProjectDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectDto' is not null or undefined
            assertParamExists('createProjectUsingPOST', 'projectDto', projectDto)
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteProject
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectUsingDELETE: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProjectUsingDELETE', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getProject
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectUsingGET: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProjectUsingGET', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getProjects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateProject
         * @param {string} id id
         * @param {CreateUpdateProjectDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectUsingPUT: async (id: string, dto: CreateUpdateProjectDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProjectUsingPUT', 'id', id)
            // verify required parameter 'dto' is not null or undefined
            assertParamExists('updateProjectUsingPUT', 'dto', dto)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createProject
         * @param {CreateUpdateProjectDto} projectDto projectDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectUsingPOST(projectDto: CreateUpdateProjectDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSummaryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectUsingPOST(projectDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteProject
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectUsingDELETE(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectUsingDELETE(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getProject
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectUsingGET(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSummaryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectUsingGET(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getProjects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectsUsingGET(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectSummaryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectsUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateProject
         * @param {string} id id
         * @param {CreateUpdateProjectDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectUsingPUT(id: string, dto: CreateUpdateProjectDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectUsingPUT(id, dto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary createProject
         * @param {CreateUpdateProjectDto} projectDto projectDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectUsingPOST(projectDto: CreateUpdateProjectDto, options?: any): AxiosPromise<ProjectSummaryDto> {
            return localVarFp.createProjectUsingPOST(projectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteProject
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectUsingDELETE(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProjectUsingDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getProject
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectUsingGET(id: string, options?: any): AxiosPromise<ProjectSummaryDto> {
            return localVarFp.getProjectUsingGET(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getProjects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsUsingGET(options?: any): AxiosPromise<Array<ProjectSummaryDto>> {
            return localVarFp.getProjectsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateProject
         * @param {string} id id
         * @param {CreateUpdateProjectDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectUsingPUT(id: string, dto: CreateUpdateProjectDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProjectUsingPUT(id, dto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary createProject
     * @param {CreateUpdateProjectDto} projectDto projectDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProjectUsingPOST(projectDto: CreateUpdateProjectDto, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProjectUsingPOST(projectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteProject
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProjectUsingDELETE(id: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProjectUsingDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getProject
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectUsingGET(id: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProjectUsingGET(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getProjects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectsUsingGET(options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProjectsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateProject
     * @param {string} id id
     * @param {CreateUpdateProjectDto} dto dto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProjectUsingPUT(id: string, dto: CreateUpdateProjectDto, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).updateProjectUsingPUT(id, dto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReposApi - axios parameter creator
 * @export
 */
export const ReposApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllRepos
         * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllReposUsingGET: async (provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getAllReposUsingGET', 'provider', provider)
            const localVarPath = `/api/v1/repos/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllWatchedRepos
         * @param {string} projectId projectId
         * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWatchedReposUsingGET: async (projectId: string, provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAllWatchedReposUsingGET', 'projectId', projectId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getAllWatchedReposUsingGET', 'provider', provider)
            const localVarPath = `/api/v1/repos/{provider}/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary unwatchRepo
         * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
         * @param {UnwatchRepoDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unwatchRepoUsingPATCH: async (provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', dto: UnwatchRepoDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('unwatchRepoUsingPATCH', 'provider', provider)
            // verify required parameter 'dto' is not null or undefined
            assertParamExists('unwatchRepoUsingPATCH', 'dto', dto)
            const localVarPath = `/api/v1/repos/{provider}/unwatch`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary watchRepo
         * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
         * @param {WatchRepoDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchRepoUsingPUT: async (provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', dto: WatchRepoDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('watchRepoUsingPUT', 'provider', provider)
            // verify required parameter 'dto' is not null or undefined
            assertParamExists('watchRepoUsingPUT', 'dto', dto)
            const localVarPath = `/api/v1/repos/{provider}/watch`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReposApi - functional programming interface
 * @export
 */
export const ReposApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReposApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary getAllRepos
         * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllReposUsingGET(provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepoSummaryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllReposUsingGET(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAllWatchedRepos
         * @param {string} projectId projectId
         * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWatchedReposUsingGET(projectId: string, provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepoSummaryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWatchedReposUsingGET(projectId, provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary unwatchRepo
         * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
         * @param {UnwatchRepoDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unwatchRepoUsingPATCH(provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', dto: UnwatchRepoDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unwatchRepoUsingPATCH(provider, dto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary watchRepo
         * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
         * @param {WatchRepoDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async watchRepoUsingPUT(provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', dto: WatchRepoDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.watchRepoUsingPUT(provider, dto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReposApi - factory interface
 * @export
 */
export const ReposApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReposApiFp(configuration)
    return {
        /**
         * 
         * @summary getAllRepos
         * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllReposUsingGET(provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', options?: any): AxiosPromise<Array<RepoSummaryDto>> {
            return localVarFp.getAllReposUsingGET(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllWatchedRepos
         * @param {string} projectId projectId
         * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWatchedReposUsingGET(projectId: string, provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', options?: any): AxiosPromise<Array<RepoSummaryDto>> {
            return localVarFp.getAllWatchedReposUsingGET(projectId, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary unwatchRepo
         * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
         * @param {UnwatchRepoDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unwatchRepoUsingPATCH(provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', dto: UnwatchRepoDto, options?: any): AxiosPromise<void> {
            return localVarFp.unwatchRepoUsingPATCH(provider, dto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary watchRepo
         * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
         * @param {WatchRepoDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchRepoUsingPUT(provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', dto: WatchRepoDto, options?: any): AxiosPromise<void> {
            return localVarFp.watchRepoUsingPUT(provider, dto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReposApi - object-oriented interface
 * @export
 * @class ReposApi
 * @extends {BaseAPI}
 */
export class ReposApi extends BaseAPI {
    /**
     * 
     * @summary getAllRepos
     * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReposApi
     */
    public getAllReposUsingGET(provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', options?: AxiosRequestConfig) {
        return ReposApiFp(this.configuration).getAllReposUsingGET(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllWatchedRepos
     * @param {string} projectId projectId
     * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReposApi
     */
    public getAllWatchedReposUsingGET(projectId: string, provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', options?: AxiosRequestConfig) {
        return ReposApiFp(this.configuration).getAllWatchedReposUsingGET(projectId, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary unwatchRepo
     * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
     * @param {UnwatchRepoDto} dto dto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReposApi
     */
    public unwatchRepoUsingPATCH(provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', dto: UnwatchRepoDto, options?: AxiosRequestConfig) {
        return ReposApiFp(this.configuration).unwatchRepoUsingPATCH(provider, dto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary watchRepo
     * @param {'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD'} provider provider
     * @param {WatchRepoDto} dto dto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReposApi
     */
    public watchRepoUsingPUT(provider: 'GIT' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AZURE' | 'TRAVISCI' | 'CIRCLECI' | 'JENKINS' | 'CODEBUILD', dto: WatchRepoDto, options?: AxiosRequestConfig) {
        return ReposApiFp(this.configuration).watchRepoUsingPUT(provider, dto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TelemetryApi - axios parameter creator
 * @export
 */
export const TelemetryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary handleDoMetrics
         * @param {WorkflowTelemetryRequest} workflowTelemetryRequest workflowTelemetryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDoMetricsUsingPOST: async (workflowTelemetryRequest: WorkflowTelemetryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowTelemetryRequest' is not null or undefined
            assertParamExists('handleDoMetricsUsingPOST', 'workflowTelemetryRequest', workflowTelemetryRequest)
            const localVarPath = `/api/v1/telemetry/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowTelemetryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handleDoProcesses
         * @param {WorkflowTelemetryRequest} workflowTelemetryRequest workflowTelemetryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDoProcessesUsingPOST: async (workflowTelemetryRequest: WorkflowTelemetryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowTelemetryRequest' is not null or undefined
            assertParamExists('handleDoProcessesUsingPOST', 'workflowTelemetryRequest', workflowTelemetryRequest)
            const localVarPath = `/api/v1/telemetry/processes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowTelemetryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelemetryApi - functional programming interface
 * @export
 */
export const TelemetryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TelemetryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary handleDoMetrics
         * @param {WorkflowTelemetryRequest} workflowTelemetryRequest workflowTelemetryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleDoMetricsUsingPOST(workflowTelemetryRequest: WorkflowTelemetryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompletableFutureOfVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleDoMetricsUsingPOST(workflowTelemetryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary handleDoProcesses
         * @param {WorkflowTelemetryRequest} workflowTelemetryRequest workflowTelemetryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleDoProcessesUsingPOST(workflowTelemetryRequest: WorkflowTelemetryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompletableFutureOfVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleDoProcessesUsingPOST(workflowTelemetryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TelemetryApi - factory interface
 * @export
 */
export const TelemetryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TelemetryApiFp(configuration)
    return {
        /**
         * 
         * @summary handleDoMetrics
         * @param {WorkflowTelemetryRequest} workflowTelemetryRequest workflowTelemetryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDoMetricsUsingPOST(workflowTelemetryRequest: WorkflowTelemetryRequest, options?: any): AxiosPromise<CompletableFutureOfVoid> {
            return localVarFp.handleDoMetricsUsingPOST(workflowTelemetryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary handleDoProcesses
         * @param {WorkflowTelemetryRequest} workflowTelemetryRequest workflowTelemetryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleDoProcessesUsingPOST(workflowTelemetryRequest: WorkflowTelemetryRequest, options?: any): AxiosPromise<CompletableFutureOfVoid> {
            return localVarFp.handleDoProcessesUsingPOST(workflowTelemetryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TelemetryApi - object-oriented interface
 * @export
 * @class TelemetryApi
 * @extends {BaseAPI}
 */
export class TelemetryApi extends BaseAPI {
    /**
     * 
     * @summary handleDoMetrics
     * @param {WorkflowTelemetryRequest} workflowTelemetryRequest workflowTelemetryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public handleDoMetricsUsingPOST(workflowTelemetryRequest: WorkflowTelemetryRequest, options?: AxiosRequestConfig) {
        return TelemetryApiFp(this.configuration).handleDoMetricsUsingPOST(workflowTelemetryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary handleDoProcesses
     * @param {WorkflowTelemetryRequest} workflowTelemetryRequest workflowTelemetryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public handleDoProcessesUsingPOST(workflowTelemetryRequest: WorkflowTelemetryRequest, options?: AxiosRequestConfig) {
        return TelemetryApiFp(this.configuration).handleDoProcessesUsingPOST(workflowTelemetryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getErroneousWorkflow
         * @param {WorkflowHighlightsQueryDto} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getErroneousWorkflowUsingPOST: async (query: WorkflowHighlightsQueryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getErroneousWorkflowUsingPOST', 'query', query)
            const localVarPath = `/api/v1/workflows/erroneous`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(query, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getWorkflowStepHistories
         * @param {string} workflowId workflowId
         * @param {WorkflowStepHistoryRequestDto} requestDto requestDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStepHistoriesUsingPOST: async (workflowId: string, requestDto: WorkflowStepHistoryRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowStepHistoriesUsingPOST', 'workflowId', workflowId)
            // verify required parameter 'requestDto' is not null or undefined
            assertParamExists('getWorkflowStepHistoriesUsingPOST', 'requestDto', requestDto)
            const localVarPath = `/api/workflows/{workflowId}/step/history`
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getWorkflows
         * @param {WorkflowSearchDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowsUsingPOST: async (dto: WorkflowSearchDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dto' is not null or undefined
            assertParamExists('getWorkflowsUsingPOST', 'dto', dto)
            const localVarPath = `/api/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary getErroneousWorkflow
         * @param {WorkflowHighlightsQueryDto} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getErroneousWorkflowUsingPOST(query: WorkflowHighlightsQueryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ErroneousWorkflowDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getErroneousWorkflowUsingPOST(query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getWorkflowStepHistories
         * @param {string} workflowId workflowId
         * @param {WorkflowStepHistoryRequestDto} requestDto requestDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowStepHistoriesUsingPOST(workflowId: string, requestDto: WorkflowStepHistoryRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowStepHistoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowStepHistoriesUsingPOST(workflowId, requestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getWorkflows
         * @param {WorkflowSearchDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowsUsingPOST(dto: WorkflowSearchDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowsUsingPOST(dto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsApiFp(configuration)
    return {
        /**
         * 
         * @summary getErroneousWorkflow
         * @param {WorkflowHighlightsQueryDto} query query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getErroneousWorkflowUsingPOST(query: WorkflowHighlightsQueryDto, options?: any): AxiosPromise<Array<ErroneousWorkflowDto>> {
            return localVarFp.getErroneousWorkflowUsingPOST(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getWorkflowStepHistories
         * @param {string} workflowId workflowId
         * @param {WorkflowStepHistoryRequestDto} requestDto requestDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStepHistoriesUsingPOST(workflowId: string, requestDto: WorkflowStepHistoryRequestDto, options?: any): AxiosPromise<Array<WorkflowStepHistoryDto>> {
            return localVarFp.getWorkflowStepHistoriesUsingPOST(workflowId, requestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getWorkflows
         * @param {WorkflowSearchDto} dto dto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowsUsingPOST(dto: WorkflowSearchDto, options?: any): AxiosPromise<Array<WorkflowViewDto>> {
            return localVarFp.getWorkflowsUsingPOST(dto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * 
     * @summary getErroneousWorkflow
     * @param {WorkflowHighlightsQueryDto} query query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getErroneousWorkflowUsingPOST(query: WorkflowHighlightsQueryDto, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getErroneousWorkflowUsingPOST(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getWorkflowStepHistories
     * @param {string} workflowId workflowId
     * @param {WorkflowStepHistoryRequestDto} requestDto requestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflowStepHistoriesUsingPOST(workflowId: string, requestDto: WorkflowStepHistoryRequestDto, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflowStepHistoriesUsingPOST(workflowId, requestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getWorkflows
     * @param {WorkflowSearchDto} dto dto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflowsUsingPOST(dto: WorkflowSearchDto, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflowsUsingPOST(dto, options).then((request) => request(this.axios, this.basePath));
    }
}


